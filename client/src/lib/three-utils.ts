import * as THREE from 'three';

export function createMeshFromData(vertices: number[][], faces: number[][]) {
  const geometry = new THREE.BufferGeometry();
  
  // Convert vertices to flat array
  const verticesArray = new Float32Array(vertices.flat());
  geometry.setAttribute('position', new THREE.BufferAttribute(verticesArray, 3));
  
  // Convert faces to indices
  const indices: number[] = [];
  faces.forEach(face => {
    if (face.length === 3) {
      indices.push(...face);
    } else if (face.length === 4) {
      // Convert quad to two triangles
      indices.push(face[0], face[1], face[2]);
      indices.push(face[0], face[2], face[3]);
    }
  });
  
  geometry.setIndex(indices);
  geometry.computeVertexNormals();
  
  return geometry;
}

export function calculateBoundingBox(vertices: number[][]) {
  if (vertices.length === 0) return null;
  
  let minX = Infinity, minY = Infinity, minZ = Infinity;
  let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
  
  vertices.forEach(([x, y, z]) => {
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    minZ = Math.min(minZ, z);
    maxX = Math.max(maxX, x);
    maxY = Math.max(maxY, y);
    maxZ = Math.max(maxZ, z);
  });
  
  return {
    min: [minX, minY, minZ],
    max: [maxX, maxY, maxZ],
    center: [(minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2],
    size: [maxX - minX, maxY - minY, maxZ - minZ]
  };
}

export function subdivideMesh(geometry: THREE.BufferGeometry, iterations: number = 1) {
  // Basic subdivision implementation
  // This would need a more sophisticated algorithm for real mesh subdivision
  return geometry;
}

export function decimateMesh(geometry: THREE.BufferGeometry, ratio: number = 0.5) {
  // Basic decimation implementation
  // This would need a proper mesh decimation algorithm
  return geometry;
}

export function smoothMesh(geometry: THREE.BufferGeometry, iterations: number = 1) {
  // Laplacian smoothing implementation
  for (let i = 0; i < iterations; i++) {
    geometry.computeVertexNormals();
  }
  return geometry;
}

export function exportMeshAsOBJ(geometry: THREE.BufferGeometry): string {
  const position = geometry.getAttribute('position');
  const index = geometry.getIndex();
  
  let objString = '# Generated by MeshLab Pro\n';
  
  // Export vertices
  for (let i = 0; i < position.count; i++) {
    const x = position.getX(i);
    const y = position.getY(i);
    const z = position.getZ(i);
    objString += `v ${x} ${y} ${z}\n`;
  }
  
  // Export faces
  if (index) {
    for (let i = 0; i < index.count; i += 3) {
      const a = index.getX(i) + 1; // OBJ indices are 1-based
      const b = index.getX(i + 1) + 1;
      const c = index.getX(i + 2) + 1;
      objString += `f ${a} ${b} ${c}\n`;
    }
  }
  
  return objString;
}
